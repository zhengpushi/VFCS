
Require Import VectorR.

(** ch8 三维旋转 *)

(* 本章将解决描述三维中对象的方向的难题，还讨论与旋转和角位移有关的概念。
   有若干方法来表示三维中的方向的角位移。三个重要方法：矩阵、欧拉角和四元数，
   以及两个鲜为人知的形式——轴角和指数映射。对每种方法，精确定义表示方法的工作原理，
   并讨论该方法的特性和优缺点。
   不同情况需要不同的技术，各种技术有其优缺点。开发人员不仅要知道每种方法的工作原理，
   还需要知道哪种技术最适合特定情况以及如何在表示方式之间进行转换。*)

(** * 8.1 “定向、朝向（Orientation）”是什么？ *)

(* 术语 Orientation 与这些相似的术语有关：
   方向 direction
   角位移 angular displacement
   旋转 rotation

   方向和朝向的根本区别：可用两个数字（球面坐标的角度）来设置三维中的方向；而朝向至少
   需要三个数字（比如欧拉角）。
   可以这样理解：在没有参考系时无法描述一个物体的位置。同样的，定向也不能用一些绝对项
   来描述。可以从一些已知的参考方向（长称为 identity 或 home 朝向）的旋转给出朝向。
   旋转量称为角位移（angular displacement）。
   换言之，描述朝向在数学上等同于描述角位移。

   定向描述了事务的一种状态。
   定向和角位移之间的区别，类似于点和矢量之间的区别。这两个术语在数学上等价，但概念上不同。
   此时，定向主要用于描述单个状态，而角位移主要用于描述两个状态之间的差异。

   这些约定是一个偏好问题，但可能对准确了解其含义和用法有所帮助。

   可能还会听到用于表示对象的定向的一个词“姿态（attitude）”，特别当该对象是飞机时。*)

(** * 8.2 矩阵形式 Matrix form *)

(* 描述3D中坐标空间的定向的一种方法：指出该坐标空间(+x,+y,+z轴）的基矢量的方向。
   根据定义，无论坐标空间的定向是什么，它们都是[1,0,0], [0,1,0], [0,0,1]。
   我们必须使用某些其他坐标空间来描述基向量。如此依赖，就可以建立两个坐标空间
   的相对朝向。

   当这些基向量用于形成3x3矩阵的行（或列）时，就是用矩阵形式（Matrix Form）表示了定向。
   另一种说法是，我们可以给出旋转矩阵表达两个坐标空间的相对朝向，旋转矩阵能够用于将向量
   从一个坐标空间变换到另一个坐标空间。*)

(** ** 8.2.1 矩阵的选择 *)
Section sec_8_2_1.
  (* 图8.3中的旋转矩阵，机体坐标空间的对象轴在直立空间中的表示在矩阵的行（也可以是列）中，
   同时，它可以将行矢量乘以该矩阵（也可以是该矩阵的转置乘以列矢量），将这些矢量从对象空间
   坐标变换为直立空间坐标。*)

  (* 一个合法性问题：为什么矩阵包含直立空间坐标下表示的体轴？为什么不用对象空间坐标来表示
     直立轴？换言之，为什么选择用一个旋转矩阵来将矢量从对象空间变换到直立空间？而不是从
     直立空间变换到对象空间呢？
     从数学上看，该问题有点可笑。因为旋转矩阵是正交的，其逆矩阵和它的转置相同。所以，
     该决定是一个很表面的（cosmetic）选择。
     但实际上，在我们看来，这很重要。问题在于你是否可以编写直观易读的代码，是否需要大量
     的约定知识。

     编程人员经常要用以下两种策略来编写程序：
     1. 一些矢量从对象空间旋转到直立空间，将其转换为矩阵乘法的代码
     2. 一些矢量从直立空间旋转到对象空间，将其转换为矩阵的逆(或转置)的乘法的代码。
     另外，如果是行矢量则左乘，列矢量则右乘，矩阵可能还要转置。
     这种使用矩阵的约定，往往是一个使用时的障碍，也是错误的来源。

     我们可以设计更好的接口函数来符合程序员高层次意图，封装与行矢量、列矢量、左乘、右乘、
     逆矩阵、转置等有关的容易混淆的线性代数的细节。
     回到一开始的问题：应该使用哪一个矩阵？答案是：它应该无关紧要。也许我们用函数
     objectToUpright() 来替换原来的 mmul()，类似的，用uprightToObject() 替换
     mmulByTranspose()。具有描述性命名坐标空间的代码版本显然更易于编写和阅读。*)
End sec_8_2_1.

(** ** 8..2 方向余弦矩阵 *)
Section sec_8_2_2.
  (* 方向余弦（Direction Cosine）矩阵与旋转矩阵相同，该术语只是指一种解释（或构造）矩阵
     的特殊方式。这意味这旋转矩阵中的每个元素等于一个输入基矢量与另一个输出基矢量的点积。

     假设第一个坐标空间的基矢量是相互正交的单位矢量p,q,r，具有相同原点的第二个坐标空间的
     基矢量是p',q',r'（这里写出 hat 符号，是为了防止混乱）。
     将矢量从第一个空间旋转到第二个空间的旋转矩阵可用每对基矢量之间的角度的余弦构造。
     而两个单位矢量的点积正好等于它们之间角度的余弦。*)

  (* 注意，有两种形式：它们所使用的旋转矩阵是互为转置的。分别介绍：
     第一种形式，书中的，在旋转矩阵的左侧使用行矢量。
     LR (Left-Row): row-vector left multiply matrix

     第二种形式，我习惯的，在旋转矩阵的右侧使用列矢量
     RC (Right-Column): matrix right multiply column-vector.
   *)

  (* 两个坐标空间的基向量（用行矢量、列矢量都无所谓了） *)
  Variable p q r p' q' r' : cvec 3.

  (** ========================================= *)
  (** LR 形式 *)
  
  (* 构造出的旋转矩阵，作用：将某限量在第一个空间下的坐标变换到第二个空间下的表示 *)
  Definition LRmat : smat 3 :=
    l2m [[<p,p'>; <q,p'>; <r,p'>];
         [<p,q'>; <q,q'>; <r,q'>];
         [<p,r'>; <q,r'>; <r,r'>]].

  (* 用法 *)
  Definition LRrot (v : rvec 3) : rvec 3 := v * LRmat.

  (** 假设这些轴是相对于第一个基来描述的，则p,q,r是平凡的形式 [1,0,0],...，而第二个
        空间的基矢量p',q',r'是任意的坐标。我们可以发现：
        矩阵的行是输出坐标空间的基矢量（用相对于输入坐标空间的坐标来表示） *)
  Lemma LR_row_is_output_basis :
    p == cv3i -> q == cv3j -> r == cv3k ->
    (mrow LRmat 0 == p'\T /\ mrow LRmat 1 == q'\T /\ mrow LRmat 2 == r'\T).
  Proof.
    intros. unfold LRmat. repeat split;
      lma; rewrite ?H,?H0,?H1,?cvdot_v3i_l,?cvdot_v3j_l,?cvdot_v3k_l; try easy.
  Qed.

  (** 假设这些轴是相对于第二个基来描述的，则p',q',r'是平凡的形式 [1,0,0],...，而第一个
        空间的基矢量p,q,r是任意的坐标。我们可以发现：
        矩阵的列是输入坐标空间的基矢量（用相对于输出坐标空间的坐标来表示） *)
  Lemma LR_col_is_input_basis :
    p' == cv3i -> q' == cv3j -> r' == cv3k ->
    (mcol LRmat 0 == p /\ mcol LRmat 1 == q /\ mcol LRmat 2 == r).
  Proof.
    intros. unfold LRmat. repeat split;
      lma; rewrite ?H,?H0,?H1,?cvdot_v3i_r,?cvdot_v3j_r,?cvdot_v3k_r; try easy.
  Qed.
  
  (** ========================================= *)
  (** RC 形式 *)
  
  (* 构造出的旋转矩阵，作用：将某限量在第一个空间下的坐标变换到第二个空间下的表示 *)
  Definition RCmat : smat 3 :=
        l2m [[<p,p'>; <p,q'>; <p,r'>];
             [<q,p'>; <q,q'>; <q,r'>];
             [<r,p'>; <r,q'>; <r,r'>]].

  (* 用法 *)
  Definition RCrot (v : cvec 3) : cvec 3 := RCmat * v.

  (** RCmat 是 LRmat 的转置 *)
  Lemma RCmat_LRmat_trans : RCmat == LRmat \T.
  Proof. lma. Qed.

  (** 假设这些轴是相对于第一个基来描述的，则p,q,r是平凡的形式 [1,0,0],...，而第二个
        空间的基矢量p',q',r'是任意的坐标。我们可以发现：
        矩阵的列是输出坐标空间的基矢量（用相对于输入坐标空间的坐标来表示） *)
  Lemma RC_col_is_output_basis :
    p == cv3i -> q == cv3j -> r == cv3k ->
    (mcol RCmat 0 == p' /\ mcol RCmat 1 == q' /\ mcol RCmat 2 == r').
  Proof.
    intros. unfold RCmat. repeat split;
      lma; rewrite ?H,?H0,?H1,?cvdot_v3i_l,?cvdot_v3j_l,?cvdot_v3k_l; try easy.
  Qed.

  (** 假设这些轴是相对于第二个基来描述的，则p',q',r'是平凡的形式 [1,0,0],...，而第一个
        空间的基矢量p,q,r是任意的坐标。我们可以发现：
        矩阵的行是输入坐标空间的基矢量（用相对于输出坐标空间的坐标来表示） *)
  Lemma RC_row_is_input_basis :
    p' == cv3i -> q' == cv3j -> r' == cv3k ->
    (mrow RCmat 0 == p\T /\ mrow RCmat 1 == q\T /\ mrow RCmat 2 == r\T).
  Proof.
    intros. unfold RCmat. repeat split;
      lma; rewrite ?H,?H0,?H1,?cvdot_v3i_r,?cvdot_v3j_r,?cvdot_v3k_r; try easy.
  Qed.

End sec_8_2_2.


(** ** 8.2.3 矩阵形式的优点 *)

(* 这是一种非常明确的表示方向的形式。有以下优点：
   1. 旋转矢量立即可用。可以使用矩阵在对象空间和直立空间之间旋转矢量。其他方式几乎都
   需要先转换到旋转矩阵来处理。（尽管四元数说可以，但还是在乘以另一种形式的旋转矩阵。）
   2. 这是图形API使用的格式。
   3. 多个角位移的连接。在第3章讨论了坐标空间的嵌套，第5.6介绍了矩阵的连接方法。
   4. 使用矩阵求逆来计算“反向”的角位移。而且由于旋转矩阵是正交的，只需要转置一下即可。*)

(** ** 8.2.4 矩阵形式的缺点
   1. 矩阵占用更多内存。9个数字来存储朝向，而不是3个数字。
   2. 人类难以使用。矩阵对于人类直接使用并不直观，数字都介于-1~+1，而且人们习惯角度。
   另外，手动构建一个非平凡的朝向需要很长时间。
   3. 矩阵可能格式不正确。矩阵中的9个数字，但实际只需3个。换言之，矩阵包含6度冗余。
   必须满足6个约束条件才能使矩阵有效表示朝向。行(列)正交且单位向量。
   
   格式错误的矩阵可能导致数字异常、奇怪的拉伸图形和其他意外行为。
   有如下可能的图形得到一个病态的矩阵：
   1. 可能包含缩放比例、倾斜、反射、投影，而经过此类运算后的对象的朝向是未定义的。
   2. 可能从外部获取了错误的数据。许多建模软件包可能生成不良格式。
   3. 由于浮点数摄入错误。大量的矩阵乘法受到有限的浮点精度的影响，可能导致格式错误的
   矩阵。这种现象称为矩阵蠕变（matrix creep）。可通过6.3.3的矩阵正交化来应对。 *)

(** * 8.3 欧拉角 *)
