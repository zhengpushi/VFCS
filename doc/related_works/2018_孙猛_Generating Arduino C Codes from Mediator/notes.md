
# 关于 Mediator，以及研究背景
基于组件的建模语言，它提供基于自动机的形式语义，并且支持层次化建模。
全功能的类型系统，有力的协调机制，该语言可用于专用领域的专家和软件工程师来确保软件系统模型的可靠性。
然而，这种强大的建模语言只对高层模型的正确性有用。
很多软件错误是由实现和模型之间的不一致造成的。
这表明，人工实现不总是精确的遵循抽象的模型和设计，尤其是高度复杂的系统。
所以，自动代码生成被提出「文献9」。
本文提出了从Mediator模型生成C的算法，可直接编译并在Arduino上执行。

代码生成的重要性早已出现。所以，为不同目标平台的很多形式化的和工业的代码生成工具已被构建。
例如，Event-B和SCADE是能够从抽象模型生成可执行代码的流行的形式化工具。
在SCADE的代码生成器以可靠性闻名，但它的可扩展性被它所接受的Esterel语言所限制。
作为一个同步语言，Esterel只形式化了一个单独嵌入的控制循环，很难建模并行和时间行为。
而且，Event-B的SCADE都只针对x86平台，它们不能生成嵌入式系统直接工作的代码。

另一方面，Ptolemy, MATLAB Simulink工具箱，LabVIEW 是流行的工业建模工具，支持平台相关的代码生成。
这些工具有大量的库和插件，几乎覆盖了所有常用的嵌入式系统和编程语言。
然而，当我们在模型上执行测试和验证技术时，这些工具的能力也受到限制。
例如，Ptolemy使用标准的JAVA作为它的语义，Simulink允许用户直接通过MATLAB语言编写组件。
据我们目前所知，用这样的全特性编程语言直接编写的模块，带有循环和动态内存分配，是很难被验证的。

# 2. 背景


# 3. Mediator-Arduino的代码生成是如何工作的
* 对于 Bounded Integer，比如 0 .. 1 ，它允许的是 0,1 这两个整数。
  首先，C不支持这种概念（违反机器实现原理，没必要之后次）。
  而且，作者认为由于它大量使用，若使用复杂结构来表示可能遇到性能下降。
  所以选择用assert断言，并且在每当这个bounded integer类型的变量被赋值之后进行。比如：
  ```
  int a = 0;
  void f () {
	  // ...
	  a = 1 - a;
	  assert (a >= 0 && a <= 1);
	  // ...
  ```
  「对此，我存疑，如果assert发生，则程序会崩溃，这并不是一个最好的处理方式」。
* list。C支持通过指针实习那无约束的列表。
  然而，C不关心容量和消耗，经常导致内存溢出和非法解引用。
  所以作者封装了一个空指针和两个整数字段来表示其容量和已占用的数量。
  ```
  struct __MR_List {
	  void * list;
	  int capacity;
	  int num_items;
	  int item_size;
  };
  typedef struct __MR_List MR_List;
  
  void init_empty_list (MR_List list, int item_size);
  void list_add (MR_List list, void * item);
  void * list_get (MR_List list, int index);
  void list_del (MR_List list, int index);
  ```
  此处的列表是类型无关的。换言之，保存或取出一个项时不可避免的要进行类型转换。
  此时，Mediator的语法检查器来负责保证类型一致性。
* 还有其他一些聪明的结构，见论文。


# 4. 案例研究
